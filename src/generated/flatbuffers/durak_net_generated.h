// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DURAKNET_DURAK_GEN_NET_H_
#define FLATBUFFERS_GENERATED_DURAKNET_DURAK_GEN_NET_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace durak {
namespace gen {
namespace net {

struct Card;
struct CardBuilder;

struct TableSlot;
struct TableSlotBuilder;

struct SeatView;
struct SeatViewBuilder;

struct Action_Attack;
struct Action_AttackBuilder;

struct ActionPair;
struct ActionPairBuilder;

struct Action_Defend;
struct Action_DefendBuilder;

struct Action_Pass;
struct Action_PassBuilder;

struct Action_Take;
struct Action_TakeBuilder;

struct PlayerActionMsg;
struct PlayerActionMsgBuilder;

struct SnapshotMsg;
struct SnapshotMsgBuilder;

struct DecisionRequest;
struct DecisionRequestBuilder;

struct Violation;
struct ViolationBuilder;

struct ServerHello;
struct ServerHelloBuilder;

struct GameOver;
struct GameOverBuilder;

struct Envelope;
struct EnvelopeBuilder;

enum class Phase : uint8_t {
  Attacking = 0,
  Defending = 1,
  Cleanup = 2,
  MIN = Attacking,
  MAX = Cleanup
};

inline const Phase (&EnumValuesPhase())[3] {
  static const Phase values[] = {
    Phase::Attacking,
    Phase::Defending,
    Phase::Cleanup
  };
  return values;
}

inline const char * const *EnumNamesPhase() {
  static const char * const names[4] = {
    "Attacking",
    "Defending",
    "Cleanup",
    nullptr
  };
  return names;
}

inline const char *EnumNamePhase(Phase e) {
  if (::flatbuffers::IsOutRange(e, Phase::Attacking, Phase::Cleanup)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPhase()[index];
}

enum class Suit : uint8_t {
  Hearts = 0,
  Diamonds = 1,
  Clubs = 2,
  Spades = 3,
  MIN = Hearts,
  MAX = Spades
};

inline const Suit (&EnumValuesSuit())[4] {
  static const Suit values[] = {
    Suit::Hearts,
    Suit::Diamonds,
    Suit::Clubs,
    Suit::Spades
  };
  return values;
}

inline const char * const *EnumNamesSuit() {
  static const char * const names[5] = {
    "Hearts",
    "Diamonds",
    "Clubs",
    "Spades",
    nullptr
  };
  return names;
}

inline const char *EnumNameSuit(Suit e) {
  if (::flatbuffers::IsOutRange(e, Suit::Hearts, Suit::Spades)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSuit()[index];
}

enum class Rank : uint8_t {
  Two = 0,
  Three = 1,
  Four = 2,
  Five = 3,
  Six = 4,
  Seven = 5,
  Eight = 6,
  Nine = 7,
  Ten = 8,
  Jack = 9,
  Queen = 10,
  King = 11,
  Ace = 12,
  MIN = Two,
  MAX = Ace
};

inline const Rank (&EnumValuesRank())[13] {
  static const Rank values[] = {
    Rank::Two,
    Rank::Three,
    Rank::Four,
    Rank::Five,
    Rank::Six,
    Rank::Seven,
    Rank::Eight,
    Rank::Nine,
    Rank::Ten,
    Rank::Jack,
    Rank::Queen,
    Rank::King,
    Rank::Ace
  };
  return values;
}

inline const char * const *EnumNamesRank() {
  static const char * const names[14] = {
    "Two",
    "Three",
    "Four",
    "Five",
    "Six",
    "Seven",
    "Eight",
    "Nine",
    "Ten",
    "Jack",
    "Queen",
    "King",
    "Ace",
    nullptr
  };
  return names;
}

inline const char *EnumNameRank(Rank e) {
  if (::flatbuffers::IsOutRange(e, Rank::Two, Rank::Ace)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRank()[index];
}

enum class Action : uint8_t {
  NONE = 0,
  Action_Attack = 1,
  Action_Defend = 2,
  Action_Pass = 3,
  Action_Take = 4,
  MIN = NONE,
  MAX = Action_Take
};

inline const Action (&EnumValuesAction())[5] {
  static const Action values[] = {
    Action::NONE,
    Action::Action_Attack,
    Action::Action_Defend,
    Action::Action_Pass,
    Action::Action_Take
  };
  return values;
}

inline const char * const *EnumNamesAction() {
  static const char * const names[6] = {
    "NONE",
    "Action_Attack",
    "Action_Defend",
    "Action_Pass",
    "Action_Take",
    nullptr
  };
  return names;
}

inline const char *EnumNameAction(Action e) {
  if (::flatbuffers::IsOutRange(e, Action::NONE, Action::Action_Take)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAction()[index];
}

template<typename T> struct ActionTraits {
  static const Action enum_value = Action::NONE;
};

template<> struct ActionTraits<durak::gen::net::Action_Attack> {
  static const Action enum_value = Action::Action_Attack;
};

template<> struct ActionTraits<durak::gen::net::Action_Defend> {
  static const Action enum_value = Action::Action_Defend;
};

template<> struct ActionTraits<durak::gen::net::Action_Pass> {
  static const Action enum_value = Action::Action_Pass;
};

template<> struct ActionTraits<durak::gen::net::Action_Take> {
  static const Action enum_value = Action::Action_Take;
};

bool VerifyAction(::flatbuffers::Verifier &verifier, const void *obj, Action type);
bool VerifyActionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Action> *types);

enum class Message : uint8_t {
  NONE = 0,
  PlayerActionMsg = 1,
  SnapshotMsg = 2,
  DecisionRequest = 3,
  Violation = 4,
  ServerHello = 5,
  GameOver = 6,
  MIN = NONE,
  MAX = GameOver
};

inline const Message (&EnumValuesMessage())[7] {
  static const Message values[] = {
    Message::NONE,
    Message::PlayerActionMsg,
    Message::SnapshotMsg,
    Message::DecisionRequest,
    Message::Violation,
    Message::ServerHello,
    Message::GameOver
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[8] = {
    "NONE",
    "PlayerActionMsg",
    "SnapshotMsg",
    "DecisionRequest",
    "Violation",
    "ServerHello",
    "GameOver",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (::flatbuffers::IsOutRange(e, Message::NONE, Message::GameOver)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message::NONE;
};

template<> struct MessageTraits<durak::gen::net::PlayerActionMsg> {
  static const Message enum_value = Message::PlayerActionMsg;
};

template<> struct MessageTraits<durak::gen::net::SnapshotMsg> {
  static const Message enum_value = Message::SnapshotMsg;
};

template<> struct MessageTraits<durak::gen::net::DecisionRequest> {
  static const Message enum_value = Message::DecisionRequest;
};

template<> struct MessageTraits<durak::gen::net::Violation> {
  static const Message enum_value = Message::Violation;
};

template<> struct MessageTraits<durak::gen::net::ServerHello> {
  static const Message enum_value = Message::ServerHello;
};

template<> struct MessageTraits<durak::gen::net::GameOver> {
  static const Message enum_value = Message::GameOver;
};

bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Message> *types);

struct Card FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CardBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUIT = 4,
    VT_RANK = 6
  };
  durak::gen::net::Suit suit() const {
    return static_cast<durak::gen::net::Suit>(GetField<uint8_t>(VT_SUIT, 0));
  }
  durak::gen::net::Rank rank() const {
    return static_cast<durak::gen::net::Rank>(GetField<uint8_t>(VT_RANK, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUIT, 1) &&
           VerifyField<uint8_t>(verifier, VT_RANK, 1) &&
           verifier.EndTable();
  }
};

struct CardBuilder {
  typedef Card Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_suit(durak::gen::net::Suit suit) {
    fbb_.AddElement<uint8_t>(Card::VT_SUIT, static_cast<uint8_t>(suit), 0);
  }
  void add_rank(durak::gen::net::Rank rank) {
    fbb_.AddElement<uint8_t>(Card::VT_RANK, static_cast<uint8_t>(rank), 0);
  }
  explicit CardBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Card> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Card>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Card> CreateCard(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    durak::gen::net::Suit suit = durak::gen::net::Suit::Hearts,
    durak::gen::net::Rank rank = durak::gen::net::Rank::Two) {
  CardBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_suit(suit);
  return builder_.Finish();
}

struct TableSlot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TableSlotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTACK = 4,
    VT_DEFEND = 6
  };
  const durak::gen::net::Card *attack() const {
    return GetPointer<const durak::gen::net::Card *>(VT_ATTACK);
  }
  const durak::gen::net::Card *defend() const {
    return GetPointer<const durak::gen::net::Card *>(VT_DEFEND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTACK) &&
           verifier.VerifyTable(attack()) &&
           VerifyOffset(verifier, VT_DEFEND) &&
           verifier.VerifyTable(defend()) &&
           verifier.EndTable();
  }
};

struct TableSlotBuilder {
  typedef TableSlot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_attack(::flatbuffers::Offset<durak::gen::net::Card> attack) {
    fbb_.AddOffset(TableSlot::VT_ATTACK, attack);
  }
  void add_defend(::flatbuffers::Offset<durak::gen::net::Card> defend) {
    fbb_.AddOffset(TableSlot::VT_DEFEND, defend);
  }
  explicit TableSlotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TableSlot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TableSlot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TableSlot> CreateTableSlot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<durak::gen::net::Card> attack = 0,
    ::flatbuffers::Offset<durak::gen::net::Card> defend = 0) {
  TableSlotBuilder builder_(_fbb);
  builder_.add_defend(defend);
  builder_.add_attack(attack);
  return builder_.Finish();
}

struct SeatView FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SeatViewBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCHEMA_VERSION = 4,
    VT_SEAT = 6,
    VT_N_PLAYERS = 8,
    VT_TRUMP = 10,
    VT_ATTACKER_IDX = 12,
    VT_DEFENDER_IDX = 14,
    VT_PHASE = 16,
    VT_TABLE = 18,
    VT_MY_HAND = 20,
    VT_OTHER_COUNTS = 22,
    VT_BOUT_CAP = 24,
    VT_ATTACKS_USED = 26,
    VT_DEFENDER_TOOK = 28
  };
  uint16_t schema_version() const {
    return GetField<uint16_t>(VT_SCHEMA_VERSION, 0);
  }
  uint8_t seat() const {
    return GetField<uint8_t>(VT_SEAT, 0);
  }
  uint8_t n_players() const {
    return GetField<uint8_t>(VT_N_PLAYERS, 0);
  }
  durak::gen::net::Suit trump() const {
    return static_cast<durak::gen::net::Suit>(GetField<uint8_t>(VT_TRUMP, 0));
  }
  uint8_t attacker_idx() const {
    return GetField<uint8_t>(VT_ATTACKER_IDX, 0);
  }
  uint8_t defender_idx() const {
    return GetField<uint8_t>(VT_DEFENDER_IDX, 0);
  }
  durak::gen::net::Phase phase() const {
    return static_cast<durak::gen::net::Phase>(GetField<uint8_t>(VT_PHASE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::TableSlot>> *table() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::TableSlot>> *>(VT_TABLE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::Card>> *my_hand() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::Card>> *>(VT_MY_HAND);
  }
  const ::flatbuffers::Vector<uint8_t> *other_counts() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_OTHER_COUNTS);
  }
  uint8_t bout_cap() const {
    return GetField<uint8_t>(VT_BOUT_CAP, 0);
  }
  uint8_t attacks_used() const {
    return GetField<uint8_t>(VT_ATTACKS_USED, 0);
  }
  bool defender_took() const {
    return GetField<uint8_t>(VT_DEFENDER_TOOK, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SCHEMA_VERSION, 2) &&
           VerifyField<uint8_t>(verifier, VT_SEAT, 1) &&
           VerifyField<uint8_t>(verifier, VT_N_PLAYERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRUMP, 1) &&
           VerifyField<uint8_t>(verifier, VT_ATTACKER_IDX, 1) &&
           VerifyField<uint8_t>(verifier, VT_DEFENDER_IDX, 1) &&
           VerifyField<uint8_t>(verifier, VT_PHASE, 1) &&
           VerifyOffset(verifier, VT_TABLE) &&
           verifier.VerifyVector(table()) &&
           verifier.VerifyVectorOfTables(table()) &&
           VerifyOffset(verifier, VT_MY_HAND) &&
           verifier.VerifyVector(my_hand()) &&
           verifier.VerifyVectorOfTables(my_hand()) &&
           VerifyOffset(verifier, VT_OTHER_COUNTS) &&
           verifier.VerifyVector(other_counts()) &&
           VerifyField<uint8_t>(verifier, VT_BOUT_CAP, 1) &&
           VerifyField<uint8_t>(verifier, VT_ATTACKS_USED, 1) &&
           VerifyField<uint8_t>(verifier, VT_DEFENDER_TOOK, 1) &&
           verifier.EndTable();
  }
};

struct SeatViewBuilder {
  typedef SeatView Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_schema_version(uint16_t schema_version) {
    fbb_.AddElement<uint16_t>(SeatView::VT_SCHEMA_VERSION, schema_version, 0);
  }
  void add_seat(uint8_t seat) {
    fbb_.AddElement<uint8_t>(SeatView::VT_SEAT, seat, 0);
  }
  void add_n_players(uint8_t n_players) {
    fbb_.AddElement<uint8_t>(SeatView::VT_N_PLAYERS, n_players, 0);
  }
  void add_trump(durak::gen::net::Suit trump) {
    fbb_.AddElement<uint8_t>(SeatView::VT_TRUMP, static_cast<uint8_t>(trump), 0);
  }
  void add_attacker_idx(uint8_t attacker_idx) {
    fbb_.AddElement<uint8_t>(SeatView::VT_ATTACKER_IDX, attacker_idx, 0);
  }
  void add_defender_idx(uint8_t defender_idx) {
    fbb_.AddElement<uint8_t>(SeatView::VT_DEFENDER_IDX, defender_idx, 0);
  }
  void add_phase(durak::gen::net::Phase phase) {
    fbb_.AddElement<uint8_t>(SeatView::VT_PHASE, static_cast<uint8_t>(phase), 0);
  }
  void add_table(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::TableSlot>>> table) {
    fbb_.AddOffset(SeatView::VT_TABLE, table);
  }
  void add_my_hand(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::Card>>> my_hand) {
    fbb_.AddOffset(SeatView::VT_MY_HAND, my_hand);
  }
  void add_other_counts(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> other_counts) {
    fbb_.AddOffset(SeatView::VT_OTHER_COUNTS, other_counts);
  }
  void add_bout_cap(uint8_t bout_cap) {
    fbb_.AddElement<uint8_t>(SeatView::VT_BOUT_CAP, bout_cap, 0);
  }
  void add_attacks_used(uint8_t attacks_used) {
    fbb_.AddElement<uint8_t>(SeatView::VT_ATTACKS_USED, attacks_used, 0);
  }
  void add_defender_took(bool defender_took) {
    fbb_.AddElement<uint8_t>(SeatView::VT_DEFENDER_TOOK, static_cast<uint8_t>(defender_took), 0);
  }
  explicit SeatViewBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SeatView> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SeatView>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SeatView> CreateSeatView(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t schema_version = 0,
    uint8_t seat = 0,
    uint8_t n_players = 0,
    durak::gen::net::Suit trump = durak::gen::net::Suit::Hearts,
    uint8_t attacker_idx = 0,
    uint8_t defender_idx = 0,
    durak::gen::net::Phase phase = durak::gen::net::Phase::Attacking,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::TableSlot>>> table = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::Card>>> my_hand = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> other_counts = 0,
    uint8_t bout_cap = 0,
    uint8_t attacks_used = 0,
    bool defender_took = false) {
  SeatViewBuilder builder_(_fbb);
  builder_.add_other_counts(other_counts);
  builder_.add_my_hand(my_hand);
  builder_.add_table(table);
  builder_.add_schema_version(schema_version);
  builder_.add_defender_took(defender_took);
  builder_.add_attacks_used(attacks_used);
  builder_.add_bout_cap(bout_cap);
  builder_.add_phase(phase);
  builder_.add_defender_idx(defender_idx);
  builder_.add_attacker_idx(attacker_idx);
  builder_.add_trump(trump);
  builder_.add_n_players(n_players);
  builder_.add_seat(seat);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SeatView> CreateSeatViewDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t schema_version = 0,
    uint8_t seat = 0,
    uint8_t n_players = 0,
    durak::gen::net::Suit trump = durak::gen::net::Suit::Hearts,
    uint8_t attacker_idx = 0,
    uint8_t defender_idx = 0,
    durak::gen::net::Phase phase = durak::gen::net::Phase::Attacking,
    const std::vector<::flatbuffers::Offset<durak::gen::net::TableSlot>> *table = nullptr,
    const std::vector<::flatbuffers::Offset<durak::gen::net::Card>> *my_hand = nullptr,
    const std::vector<uint8_t> *other_counts = nullptr,
    uint8_t bout_cap = 0,
    uint8_t attacks_used = 0,
    bool defender_took = false) {
  auto table__ = table ? _fbb.CreateVector<::flatbuffers::Offset<durak::gen::net::TableSlot>>(*table) : 0;
  auto my_hand__ = my_hand ? _fbb.CreateVector<::flatbuffers::Offset<durak::gen::net::Card>>(*my_hand) : 0;
  auto other_counts__ = other_counts ? _fbb.CreateVector<uint8_t>(*other_counts) : 0;
  return durak::gen::net::CreateSeatView(
      _fbb,
      schema_version,
      seat,
      n_players,
      trump,
      attacker_idx,
      defender_idx,
      phase,
      table__,
      my_hand__,
      other_counts__,
      bout_cap,
      attacks_used,
      defender_took);
}

struct Action_Attack FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Action_AttackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTOR = 4,
    VT_CARDS = 6
  };
  uint8_t actor() const {
    return GetField<uint8_t>(VT_ACTOR, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::Card>> *cards() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::Card>> *>(VT_CARDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTOR, 1) &&
           VerifyOffset(verifier, VT_CARDS) &&
           verifier.VerifyVector(cards()) &&
           verifier.VerifyVectorOfTables(cards()) &&
           verifier.EndTable();
  }
};

struct Action_AttackBuilder {
  typedef Action_Attack Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_actor(uint8_t actor) {
    fbb_.AddElement<uint8_t>(Action_Attack::VT_ACTOR, actor, 0);
  }
  void add_cards(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::Card>>> cards) {
    fbb_.AddOffset(Action_Attack::VT_CARDS, cards);
  }
  explicit Action_AttackBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Action_Attack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Action_Attack>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Action_Attack> CreateAction_Attack(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t actor = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::Card>>> cards = 0) {
  Action_AttackBuilder builder_(_fbb);
  builder_.add_cards(cards);
  builder_.add_actor(actor);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Action_Attack> CreateAction_AttackDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t actor = 0,
    const std::vector<::flatbuffers::Offset<durak::gen::net::Card>> *cards = nullptr) {
  auto cards__ = cards ? _fbb.CreateVector<::flatbuffers::Offset<durak::gen::net::Card>>(*cards) : 0;
  return durak::gen::net::CreateAction_Attack(
      _fbb,
      actor,
      cards__);
}

struct ActionPair FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ActionPairBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTACK = 4,
    VT_DEFEND = 6
  };
  const durak::gen::net::Card *attack() const {
    return GetPointer<const durak::gen::net::Card *>(VT_ATTACK);
  }
  const durak::gen::net::Card *defend() const {
    return GetPointer<const durak::gen::net::Card *>(VT_DEFEND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTACK) &&
           verifier.VerifyTable(attack()) &&
           VerifyOffset(verifier, VT_DEFEND) &&
           verifier.VerifyTable(defend()) &&
           verifier.EndTable();
  }
};

struct ActionPairBuilder {
  typedef ActionPair Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_attack(::flatbuffers::Offset<durak::gen::net::Card> attack) {
    fbb_.AddOffset(ActionPair::VT_ATTACK, attack);
  }
  void add_defend(::flatbuffers::Offset<durak::gen::net::Card> defend) {
    fbb_.AddOffset(ActionPair::VT_DEFEND, defend);
  }
  explicit ActionPairBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ActionPair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ActionPair>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ActionPair> CreateActionPair(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<durak::gen::net::Card> attack = 0,
    ::flatbuffers::Offset<durak::gen::net::Card> defend = 0) {
  ActionPairBuilder builder_(_fbb);
  builder_.add_defend(defend);
  builder_.add_attack(attack);
  return builder_.Finish();
}

struct Action_Defend FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Action_DefendBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTOR = 4,
    VT_PAIRS = 6
  };
  uint8_t actor() const {
    return GetField<uint8_t>(VT_ACTOR, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::ActionPair>> *pairs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::ActionPair>> *>(VT_PAIRS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTOR, 1) &&
           VerifyOffset(verifier, VT_PAIRS) &&
           verifier.VerifyVector(pairs()) &&
           verifier.VerifyVectorOfTables(pairs()) &&
           verifier.EndTable();
  }
};

struct Action_DefendBuilder {
  typedef Action_Defend Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_actor(uint8_t actor) {
    fbb_.AddElement<uint8_t>(Action_Defend::VT_ACTOR, actor, 0);
  }
  void add_pairs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::ActionPair>>> pairs) {
    fbb_.AddOffset(Action_Defend::VT_PAIRS, pairs);
  }
  explicit Action_DefendBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Action_Defend> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Action_Defend>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Action_Defend> CreateAction_Defend(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t actor = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<durak::gen::net::ActionPair>>> pairs = 0) {
  Action_DefendBuilder builder_(_fbb);
  builder_.add_pairs(pairs);
  builder_.add_actor(actor);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Action_Defend> CreateAction_DefendDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t actor = 0,
    const std::vector<::flatbuffers::Offset<durak::gen::net::ActionPair>> *pairs = nullptr) {
  auto pairs__ = pairs ? _fbb.CreateVector<::flatbuffers::Offset<durak::gen::net::ActionPair>>(*pairs) : 0;
  return durak::gen::net::CreateAction_Defend(
      _fbb,
      actor,
      pairs__);
}

struct Action_Pass FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Action_PassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTOR = 4
  };
  uint8_t actor() const {
    return GetField<uint8_t>(VT_ACTOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTOR, 1) &&
           verifier.EndTable();
  }
};

struct Action_PassBuilder {
  typedef Action_Pass Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_actor(uint8_t actor) {
    fbb_.AddElement<uint8_t>(Action_Pass::VT_ACTOR, actor, 0);
  }
  explicit Action_PassBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Action_Pass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Action_Pass>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Action_Pass> CreateAction_Pass(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t actor = 0) {
  Action_PassBuilder builder_(_fbb);
  builder_.add_actor(actor);
  return builder_.Finish();
}

struct Action_Take FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Action_TakeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTOR = 4
  };
  uint8_t actor() const {
    return GetField<uint8_t>(VT_ACTOR, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTOR, 1) &&
           verifier.EndTable();
  }
};

struct Action_TakeBuilder {
  typedef Action_Take Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_actor(uint8_t actor) {
    fbb_.AddElement<uint8_t>(Action_Take::VT_ACTOR, actor, 0);
  }
  explicit Action_TakeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Action_Take> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Action_Take>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Action_Take> CreateAction_Take(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t actor = 0) {
  Action_TakeBuilder builder_(_fbb);
  builder_.add_actor(actor);
  return builder_.Finish();
}

struct PlayerActionMsg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerActionMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_ID = 4,
    VT_ACTION_TYPE = 6,
    VT_ACTION = 8
  };
  uint64_t msg_id() const {
    return GetField<uint64_t>(VT_MSG_ID, 0);
  }
  durak::gen::net::Action action_type() const {
    return static_cast<durak::gen::net::Action>(GetField<uint8_t>(VT_ACTION_TYPE, 0));
  }
  const void *action() const {
    return GetPointer<const void *>(VT_ACTION);
  }
  template<typename T> const T *action_as() const;
  const durak::gen::net::Action_Attack *action_as_Action_Attack() const {
    return action_type() == durak::gen::net::Action::Action_Attack ? static_cast<const durak::gen::net::Action_Attack *>(action()) : nullptr;
  }
  const durak::gen::net::Action_Defend *action_as_Action_Defend() const {
    return action_type() == durak::gen::net::Action::Action_Defend ? static_cast<const durak::gen::net::Action_Defend *>(action()) : nullptr;
  }
  const durak::gen::net::Action_Pass *action_as_Action_Pass() const {
    return action_type() == durak::gen::net::Action::Action_Pass ? static_cast<const durak::gen::net::Action_Pass *>(action()) : nullptr;
  }
  const durak::gen::net::Action_Take *action_as_Action_Take() const {
    return action_type() == durak::gen::net::Action::Action_Take ? static_cast<const durak::gen::net::Action_Take *>(action()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MSG_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_ACTION_TYPE, 1) &&
           VerifyOffset(verifier, VT_ACTION) &&
           VerifyAction(verifier, action(), action_type()) &&
           verifier.EndTable();
  }
};

template<> inline const durak::gen::net::Action_Attack *PlayerActionMsg::action_as<durak::gen::net::Action_Attack>() const {
  return action_as_Action_Attack();
}

template<> inline const durak::gen::net::Action_Defend *PlayerActionMsg::action_as<durak::gen::net::Action_Defend>() const {
  return action_as_Action_Defend();
}

template<> inline const durak::gen::net::Action_Pass *PlayerActionMsg::action_as<durak::gen::net::Action_Pass>() const {
  return action_as_Action_Pass();
}

template<> inline const durak::gen::net::Action_Take *PlayerActionMsg::action_as<durak::gen::net::Action_Take>() const {
  return action_as_Action_Take();
}

struct PlayerActionMsgBuilder {
  typedef PlayerActionMsg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_id(uint64_t msg_id) {
    fbb_.AddElement<uint64_t>(PlayerActionMsg::VT_MSG_ID, msg_id, 0);
  }
  void add_action_type(durak::gen::net::Action action_type) {
    fbb_.AddElement<uint8_t>(PlayerActionMsg::VT_ACTION_TYPE, static_cast<uint8_t>(action_type), 0);
  }
  void add_action(::flatbuffers::Offset<void> action) {
    fbb_.AddOffset(PlayerActionMsg::VT_ACTION, action);
  }
  explicit PlayerActionMsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerActionMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerActionMsg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerActionMsg> CreatePlayerActionMsg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t msg_id = 0,
    durak::gen::net::Action action_type = durak::gen::net::Action::NONE,
    ::flatbuffers::Offset<void> action = 0) {
  PlayerActionMsgBuilder builder_(_fbb);
  builder_.add_msg_id(msg_id);
  builder_.add_action(action);
  builder_.add_action_type(action_type);
  return builder_.Finish();
}

struct SnapshotMsg FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SnapshotMsgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_ID = 4,
    VT_VIEW = 6
  };
  uint64_t msg_id() const {
    return GetField<uint64_t>(VT_MSG_ID, 0);
  }
  const durak::gen::net::SeatView *view() const {
    return GetPointer<const durak::gen::net::SeatView *>(VT_VIEW);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MSG_ID, 8) &&
           VerifyOffset(verifier, VT_VIEW) &&
           verifier.VerifyTable(view()) &&
           verifier.EndTable();
  }
};

struct SnapshotMsgBuilder {
  typedef SnapshotMsg Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_id(uint64_t msg_id) {
    fbb_.AddElement<uint64_t>(SnapshotMsg::VT_MSG_ID, msg_id, 0);
  }
  void add_view(::flatbuffers::Offset<durak::gen::net::SeatView> view) {
    fbb_.AddOffset(SnapshotMsg::VT_VIEW, view);
  }
  explicit SnapshotMsgBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SnapshotMsg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SnapshotMsg>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SnapshotMsg> CreateSnapshotMsg(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t msg_id = 0,
    ::flatbuffers::Offset<durak::gen::net::SeatView> view = 0) {
  SnapshotMsgBuilder builder_(_fbb);
  builder_.add_msg_id(msg_id);
  builder_.add_view(view);
  return builder_.Finish();
}

struct DecisionRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DecisionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_ID = 4,
    VT_ACTOR = 6,
    VT_DEADLINE_EPOCH_MS = 8
  };
  uint64_t msg_id() const {
    return GetField<uint64_t>(VT_MSG_ID, 0);
  }
  uint8_t actor() const {
    return GetField<uint8_t>(VT_ACTOR, 0);
  }
  uint64_t deadline_epoch_ms() const {
    return GetField<uint64_t>(VT_DEADLINE_EPOCH_MS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MSG_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_ACTOR, 1) &&
           VerifyField<uint64_t>(verifier, VT_DEADLINE_EPOCH_MS, 8) &&
           verifier.EndTable();
  }
};

struct DecisionRequestBuilder {
  typedef DecisionRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_id(uint64_t msg_id) {
    fbb_.AddElement<uint64_t>(DecisionRequest::VT_MSG_ID, msg_id, 0);
  }
  void add_actor(uint8_t actor) {
    fbb_.AddElement<uint8_t>(DecisionRequest::VT_ACTOR, actor, 0);
  }
  void add_deadline_epoch_ms(uint64_t deadline_epoch_ms) {
    fbb_.AddElement<uint64_t>(DecisionRequest::VT_DEADLINE_EPOCH_MS, deadline_epoch_ms, 0);
  }
  explicit DecisionRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DecisionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DecisionRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DecisionRequest> CreateDecisionRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t msg_id = 0,
    uint8_t actor = 0,
    uint64_t deadline_epoch_ms = 0) {
  DecisionRequestBuilder builder_(_fbb);
  builder_.add_deadline_epoch_ms(deadline_epoch_ms);
  builder_.add_msg_id(msg_id);
  builder_.add_actor(actor);
  return builder_.Finish();
}

struct Violation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ViolationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_ID = 4,
    VT_CODE = 6,
    VT_TEXT = 8
  };
  uint64_t msg_id() const {
    return GetField<uint64_t>(VT_MSG_ID, 0);
  }
  int16_t code() const {
    return GetField<int16_t>(VT_CODE, 0);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MSG_ID, 8) &&
           VerifyField<int16_t>(verifier, VT_CODE, 2) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct ViolationBuilder {
  typedef Violation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_id(uint64_t msg_id) {
    fbb_.AddElement<uint64_t>(Violation::VT_MSG_ID, msg_id, 0);
  }
  void add_code(int16_t code) {
    fbb_.AddElement<int16_t>(Violation::VT_CODE, code, 0);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(Violation::VT_TEXT, text);
  }
  explicit ViolationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Violation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Violation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Violation> CreateViolation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t msg_id = 0,
    int16_t code = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  ViolationBuilder builder_(_fbb);
  builder_.add_msg_id(msg_id);
  builder_.add_text(text);
  builder_.add_code(code);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Violation> CreateViolationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t msg_id = 0,
    int16_t code = 0,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return durak::gen::net::CreateViolation(
      _fbb,
      msg_id,
      code,
      text__);
}

struct ServerHello FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ServerHelloBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_ID = 4,
    VT_SCHEMA_VERSION = 6
  };
  uint64_t msg_id() const {
    return GetField<uint64_t>(VT_MSG_ID, 0);
  }
  uint16_t schema_version() const {
    return GetField<uint16_t>(VT_SCHEMA_VERSION, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MSG_ID, 8) &&
           VerifyField<uint16_t>(verifier, VT_SCHEMA_VERSION, 2) &&
           verifier.EndTable();
  }
};

struct ServerHelloBuilder {
  typedef ServerHello Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_id(uint64_t msg_id) {
    fbb_.AddElement<uint64_t>(ServerHello::VT_MSG_ID, msg_id, 0);
  }
  void add_schema_version(uint16_t schema_version) {
    fbb_.AddElement<uint16_t>(ServerHello::VT_SCHEMA_VERSION, schema_version, 0);
  }
  explicit ServerHelloBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ServerHello> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ServerHello>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ServerHello> CreateServerHello(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t msg_id = 0,
    uint16_t schema_version = 0) {
  ServerHelloBuilder builder_(_fbb);
  builder_.add_msg_id(msg_id);
  builder_.add_schema_version(schema_version);
  return builder_.Finish();
}

struct GameOver FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GameOverBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_ID = 4,
    VT_LOSER = 6,
    VT_WINNERS = 8,
    VT_RANKING = 10,
    VT_REASON = 12
  };
  uint64_t msg_id() const {
    return GetField<uint64_t>(VT_MSG_ID, 0);
  }
  uint8_t loser() const {
    return GetField<uint8_t>(VT_LOSER, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *winners() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_WINNERS);
  }
  const ::flatbuffers::Vector<uint8_t> *ranking() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_RANKING);
  }
  const ::flatbuffers::String *reason() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REASON);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_MSG_ID, 8) &&
           VerifyField<uint8_t>(verifier, VT_LOSER, 1) &&
           VerifyOffset(verifier, VT_WINNERS) &&
           verifier.VerifyVector(winners()) &&
           VerifyOffset(verifier, VT_RANKING) &&
           verifier.VerifyVector(ranking()) &&
           VerifyOffset(verifier, VT_REASON) &&
           verifier.VerifyString(reason()) &&
           verifier.EndTable();
  }
};

struct GameOverBuilder {
  typedef GameOver Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_msg_id(uint64_t msg_id) {
    fbb_.AddElement<uint64_t>(GameOver::VT_MSG_ID, msg_id, 0);
  }
  void add_loser(uint8_t loser) {
    fbb_.AddElement<uint8_t>(GameOver::VT_LOSER, loser, 0);
  }
  void add_winners(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> winners) {
    fbb_.AddOffset(GameOver::VT_WINNERS, winners);
  }
  void add_ranking(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ranking) {
    fbb_.AddOffset(GameOver::VT_RANKING, ranking);
  }
  void add_reason(::flatbuffers::Offset<::flatbuffers::String> reason) {
    fbb_.AddOffset(GameOver::VT_REASON, reason);
  }
  explicit GameOverBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GameOver> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GameOver>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GameOver> CreateGameOver(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t msg_id = 0,
    uint8_t loser = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> winners = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ranking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reason = 0) {
  GameOverBuilder builder_(_fbb);
  builder_.add_msg_id(msg_id);
  builder_.add_reason(reason);
  builder_.add_ranking(ranking);
  builder_.add_winners(winners);
  builder_.add_loser(loser);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GameOver> CreateGameOverDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t msg_id = 0,
    uint8_t loser = 0,
    const std::vector<uint8_t> *winners = nullptr,
    const std::vector<uint8_t> *ranking = nullptr,
    const char *reason = nullptr) {
  auto winners__ = winners ? _fbb.CreateVector<uint8_t>(*winners) : 0;
  auto ranking__ = ranking ? _fbb.CreateVector<uint8_t>(*ranking) : 0;
  auto reason__ = reason ? _fbb.CreateString(reason) : 0;
  return durak::gen::net::CreateGameOver(
      _fbb,
      msg_id,
      loser,
      winners__,
      ranking__,
      reason__);
}

struct Envelope FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnvelopeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  durak::gen::net::Message message_type() const {
    return static_cast<durak::gen::net::Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const durak::gen::net::PlayerActionMsg *message_as_PlayerActionMsg() const {
    return message_type() == durak::gen::net::Message::PlayerActionMsg ? static_cast<const durak::gen::net::PlayerActionMsg *>(message()) : nullptr;
  }
  const durak::gen::net::SnapshotMsg *message_as_SnapshotMsg() const {
    return message_type() == durak::gen::net::Message::SnapshotMsg ? static_cast<const durak::gen::net::SnapshotMsg *>(message()) : nullptr;
  }
  const durak::gen::net::DecisionRequest *message_as_DecisionRequest() const {
    return message_type() == durak::gen::net::Message::DecisionRequest ? static_cast<const durak::gen::net::DecisionRequest *>(message()) : nullptr;
  }
  const durak::gen::net::Violation *message_as_Violation() const {
    return message_type() == durak::gen::net::Message::Violation ? static_cast<const durak::gen::net::Violation *>(message()) : nullptr;
  }
  const durak::gen::net::ServerHello *message_as_ServerHello() const {
    return message_type() == durak::gen::net::Message::ServerHello ? static_cast<const durak::gen::net::ServerHello *>(message()) : nullptr;
  }
  const durak::gen::net::GameOver *message_as_GameOver() const {
    return message_type() == durak::gen::net::Message::GameOver ? static_cast<const durak::gen::net::GameOver *>(message()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const durak::gen::net::PlayerActionMsg *Envelope::message_as<durak::gen::net::PlayerActionMsg>() const {
  return message_as_PlayerActionMsg();
}

template<> inline const durak::gen::net::SnapshotMsg *Envelope::message_as<durak::gen::net::SnapshotMsg>() const {
  return message_as_SnapshotMsg();
}

template<> inline const durak::gen::net::DecisionRequest *Envelope::message_as<durak::gen::net::DecisionRequest>() const {
  return message_as_DecisionRequest();
}

template<> inline const durak::gen::net::Violation *Envelope::message_as<durak::gen::net::Violation>() const {
  return message_as_Violation();
}

template<> inline const durak::gen::net::ServerHello *Envelope::message_as<durak::gen::net::ServerHello>() const {
  return message_as_ServerHello();
}

template<> inline const durak::gen::net::GameOver *Envelope::message_as<durak::gen::net::GameOver>() const {
  return message_as_GameOver();
}

struct EnvelopeBuilder {
  typedef Envelope Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message_type(durak::gen::net::Message message_type) {
    fbb_.AddElement<uint8_t>(Envelope::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(::flatbuffers::Offset<void> message) {
    fbb_.AddOffset(Envelope::VT_MESSAGE, message);
  }
  explicit EnvelopeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Envelope> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Envelope>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Envelope> CreateEnvelope(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    durak::gen::net::Message message_type = durak::gen::net::Message::NONE,
    ::flatbuffers::Offset<void> message = 0) {
  EnvelopeBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyAction(::flatbuffers::Verifier &verifier, const void *obj, Action type) {
  switch (type) {
    case Action::NONE: {
      return true;
    }
    case Action::Action_Attack: {
      auto ptr = reinterpret_cast<const durak::gen::net::Action_Attack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Action::Action_Defend: {
      auto ptr = reinterpret_cast<const durak::gen::net::Action_Defend *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Action::Action_Pass: {
      auto ptr = reinterpret_cast<const durak::gen::net::Action_Pass *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Action::Action_Take: {
      auto ptr = reinterpret_cast<const durak::gen::net::Action_Take *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyActionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Action> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAction(
        verifier,  values->Get(i), types->GetEnum<Action>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyMessage(::flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message::NONE: {
      return true;
    }
    case Message::PlayerActionMsg: {
      auto ptr = reinterpret_cast<const durak::gen::net::PlayerActionMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::SnapshotMsg: {
      auto ptr = reinterpret_cast<const durak::gen::net::SnapshotMsg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::DecisionRequest: {
      auto ptr = reinterpret_cast<const durak::gen::net::DecisionRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::Violation: {
      auto ptr = reinterpret_cast<const durak::gen::net::Violation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::ServerHello: {
      auto ptr = reinterpret_cast<const durak::gen::net::ServerHello *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message::GameOver: {
      auto ptr = reinterpret_cast<const durak::gen::net::GameOver *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Message> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const durak::gen::net::Envelope *GetEnvelope(const void *buf) {
  return ::flatbuffers::GetRoot<durak::gen::net::Envelope>(buf);
}

inline const durak::gen::net::Envelope *GetSizePrefixedEnvelope(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<durak::gen::net::Envelope>(buf);
}

inline bool VerifyEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<durak::gen::net::Envelope>(nullptr);
}

inline bool VerifySizePrefixedEnvelopeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<durak::gen::net::Envelope>(nullptr);
}

inline void FinishEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<durak::gen::net::Envelope> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedEnvelopeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<durak::gen::net::Envelope> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace net
}  // namespace gen
}  // namespace durak

#endif  // FLATBUFFERS_GENERATED_DURAKNET_DURAK_GEN_NET_H_
